<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>BVH / Octree + Worker Pool with Corrected Collision Logic</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #dfe8ff;
    }

    #renderCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #ui {
      position: absolute;
      top: 8px;
      left: 8px;
      background: #ffffffe0;
      padding: 8px 12px;
      border-radius: 8px;
      font: 13px/1.4 sans-serif;
      box-shadow: 0 2px 6px #0004;
      z-index: 10;
    }

    #ui label {
      display: block;
      margin-top: 4px;
    }

    /* Collision table styling */
    #collisionTable {
      position: absolute;
      bottom: 8px;
      left: 8px;
      width: 200px;
      background: #ffffffcc;
      padding: 8px;
      border: 1px solid #888;
      max-height: 250px;
      overflow-y: auto;
      font-size: 12px;
      z-index: 10;
    }

    /* Table row pointer */
    #collisionTable tr[data-node] {
      cursor: pointer;
    }

    /* Highlighted row background */
    #collisionTable tr.highlighted {
      background-color: #ffff99;
    }
  </style>
</head>

<body>
  <canvas id="renderCanvas"></canvas>

  <div id="ui">
    <label>Structure:
      <select id="structure">
        <option value="bvh">BVH (adaptive AABB)</option>
        <option value="oct">Octree (adaptive AABB)</option>
        <option value="octCube">Octree (cubic)</option>
      </select>
    </label>
    <label>Min entities / leaf:
      <input id="minLeaf" type="number" value="6" min="1" max="256" step="1">
    </label>
    <label>Point count:
      <input id="numPts" type="number" value="10000" min="100" max="200000" step="1000">
    </label>
    <button id="rebuild">Re-build</button>
    <button id="shoot">Shoot Ball</button>
    <div id="stats" style="margin-top:6px;font-size:12px"></div>
  </div>

  <div id="collisionTable"></div>

  <!-- ────────────── WORKER CODE (inline) ────────────── -->
  <script id="oct-worker" type="javascript/worker">
    // Highly-optimized BVH/Octree builder as a standalone Web Worker
  
    const EPS = Number.EPSILON;
  
    /** Compute AABB over a subset of points */
    function computeAABB(p, s, r, idx, len) {
      let xmin =  1e9, ymin =  1e9, zmin =  1e9;
      let xmax = -1e9, ymax = -1e9, zmax = -1e9;
      for (let i = 0; i < len; i++) {
        const vi = idx[i] * 3;
        const x = p[vi], y = p[vi + 1], z = p[vi + 2];
        const sx = s[vi], sy = s[vi + 1], sz = s[vi + 2];
        const rad = r[idx[i]] || EPS;
        const minx = x - rad * sx, maxx = x + rad * sx;
        const miny = y - rad * sy, maxy = y + rad * sy;
        const minz = z - rad * sz, maxz = z + rad * sz;
        if (minx < xmin) xmin = minx;
        if (maxx > xmax) xmax = maxx;
        if (miny < ymin) ymin = miny;
        if (maxy > ymax) ymax = maxy;
        if (minz < zmin) zmin = minz;
        if (maxz > zmax) zmax = maxz;
      }
      return [xmin, ymin, zmin, xmax, ymax, zmax];
    }
  
    /** Build a BVH over points (with child pointers) */
    function buildBVH(p, s, r, minLeaf) {
      const N = p.length / 3;
      if (N === 0) {
        return {
          data: new Float32Array(0),
          leafFlags: new Uint8Array(0),
          childL: new Int32Array(0),
          childR: new Int32Array(0),
          leafIndices: []
        };
      }
  
      // 1) Create one master indices buffer
      const indices = new Uint32Array(N);
      for (let i = 0; i < N; i++) indices[i] = i;
  
      // Job structure for iterative splitting
      function Job(start, len, parentIndex, isLeft) {
        this.start = start;        // start offset into indices
        this.len = len;            // number of points
        this.parentIndex = parentIndex;  // index into jobList or -1
        this.isLeft = isLeft;      // if this is left child of parent
        this.leaf = false;         // set later
        this.nodeIndex = -1;       // set after jobList is full
      }
  
      const jobList = [];
      const stack = [];
      stack.push(new Job(0, N, -1, false));
  
      // 2) First pass: gather all jobs and partition indices in place
      while (stack.length > 0) {
        const job = stack.pop();
        jobList.push(job);
  
        const currStart = job.start;
        const currLen = job.len;
  
        // Compute bounding box to choose split axis
        const box = computeAABB(
          p,
          s,
          r,
          indices.subarray(currStart, currStart + currLen),
          currLen
        );
        const cx = 0.5 * (box[0] + box[3]);
        const cy = 0.5 * (box[1] + box[4]);
        const cz = 0.5 * (box[2] + box[5]);
        const hx = 0.5 * (box[3] - box[0]);
        const hy = 0.5 * (box[4] - box[1]);
        const hz = 0.5 * (box[5] - box[2]);
  
        let isLeaf = true;
        if (currLen > minLeaf) {
          // pick axis with largest span
          let axis = hx * 2 >= hy * 2 ? 0 : 1;
          if (hz * 2 > (axis === 0 ? hx * 2 : hy * 2)) {
            axis = 2;
          }
          const midVal = axis === 0 ? cx : axis === 1 ? cy : cz;
  
          // partition in place so that indices ≤ midVal come first
          let leftWrite = currStart;
          for (let i = currStart; i < currStart + currLen; i++) {
            const v = p[indices[i] * 3 + axis];
            if (v <= midVal) {
              const tmp = indices[i];
              indices[i] = indices[leftWrite];
              indices[leftWrite] = tmp;
              leftWrite++;
            }
          }
          const leftCount = leftWrite - currStart;
          const rightCount = currLen - leftCount;
  
          if (leftCount >= minLeaf && rightCount >= minLeaf) {
            isLeaf = false;
            // push right child first so left is processed last (stack LIFO)
            stack.push(new Job(currStart + leftCount, rightCount, jobList.length - 1, false));
            stack.push(new Job(currStart, leftCount, jobList.length - 1, true));
          }
        }
        job.leaf = isLeaf;
      }
  
      // 3) Assign nodeIndex to each job
      const Nnodes = jobList.length;
      for (let i = 0; i < Nnodes; i++) {
        jobList[i].nodeIndex = i;
      }
  
      // 4) Allocate output arrays
      const data = new Float32Array(Nnodes * 6);    // [cx, cy, cz, hx, hy, hz]
      const leafFlags = new Uint8Array(Nnodes);     // 1 if leaf
      const childL = new Int32Array(Nnodes);        // left child idx
      const childR = new Int32Array(Nnodes);        // right child idx
      const leafIndices = [];
  
      for (let i = 0; i < Nnodes; i++) {
        childL[i] = -1;
        childR[i] = -1;
      }
  
      // 5) Second pass: fill in node bounds, flags, children, leafIndices
      for (let i = 0; i < Nnodes; i++) {
        const job = jobList[i];
        const start = job.start;
        const len = job.len;
        const subIdx = indices.subarray(start, start + len);
  
        const box = computeAABB(p, s, r, subIdx, len);
        const cx = 0.5 * (box[0] + box[3]);
        const cy = 0.5 * (box[1] + box[4]);
        const cz = 0.5 * (box[2] + box[5]);
        const hx = 0.5 * (box[3] - box[0]);
        const hy = 0.5 * (box[4] - box[1]);
        const hz = 0.5 * (box[5] - box[2]);
  
        const offset = i * 6;
        data[offset]     = cx;
        data[offset + 1] = cy;
        data[offset + 2] = cz;
        data[offset + 3] = hx;
        data[offset + 4] = hy;
        data[offset + 5] = hz;
  
        leafFlags[i] = job.leaf ? 1 : 0;
        if (job.leaf) {
          // copy leaf indices into new Uint32Array
          leafIndices.push(new Uint32Array(subIdx));
        }
  
        if (job.parentIndex >= 0) {
          const parentNodeIndex = jobList[job.parentIndex].nodeIndex;
          if (job.isLeft) {
            childL[parentNodeIndex] = job.nodeIndex;
          } else {
            childR[parentNodeIndex] = job.nodeIndex;
          }
        }
      }
  
      return { data, leafFlags, childL, childR, leafIndices };
    }
  
    /** Build a (pointer-free) Octree over points */
    function buildOctree(p, s, r, minLeaf, cubic) {
      const N = p.length / 3;
      if (N === 0) {
        return {
          data: new Float32Array(0),
          leafFlags: new Uint8Array(0),
          childL: new Int32Array(0),
          childR: new Int32Array(0)
        };
      }
  
      // one master indices buffer
      const indices = new Uint32Array(N);
      for (let i = 0; i < N; i++) indices[i] = i;
  
      // compute root bounding box
      let rootBox = computeAABB(p, s, r, indices, N);
      if (cubic) {
        const sizeX = rootBox[3] - rootBox[0];
        const sizeY = rootBox[4] - rootBox[1];
        const sizeZ = rootBox[5] - rootBox[2];
        const size = Math.max(sizeX, sizeY, sizeZ);
        const cx = 0.5 * (rootBox[0] + rootBox[3]);
        const cy = 0.5 * (rootBox[1] + rootBox[4]);
        const cz = 0.5 * (rootBox[2] + rootBox[5]);
        rootBox = [
          cx - 0.5 * size, cy - 0.5 * size, cz - 0.5 * size,
          cx + 0.5 * size, cy + 0.5 * size, cz + 0.5 * size
        ];
      }
  
      function OTJob(start, len, box) {
        this.start = start;
        this.len = len;
        this.box = box;  // [minX, minY, minZ, maxX, maxY, maxZ]
      }
  
      const stack = [];
      const outBoxes = [];      // flattened [cx,cy,cz,hx,hy,hz,...]
      const leafFlagsArr = [];  // parallel array of 1/0
  
      stack.push(new OTJob(0, N, rootBox));
  
      const counts = new Uint32Array(8);
  
      // iterative loop
      while (stack.length > 0) {
        const job = stack.pop();
        const [minX, minY, minZ, maxX, maxY, maxZ] = job.box;
        const cx = 0.5 * (minX + maxX);
        const cy = 0.5 * (minY + maxY);
        const cz = 0.5 * (minZ + maxZ);
        const hx = 0.5 * (maxX - minX);
        const hy = 0.5 * (maxY - minY);
        const hz = 0.5 * (maxZ - minZ);
  
        let isLeaf = true;
        if (job.len > minLeaf) {
          counts.fill(0);
          // count points per octant
          for (let i = 0; i < job.len; i++) {
            const vi = indices[job.start + i] * 3;
            let oct = 0;
            if (p[vi]     > cx) oct |= 1;
            if (p[vi + 1] > cy) oct |= 2;
            if (p[vi + 2] > cz) oct |= 4;
            counts[oct]++;
          }
          let nonEmpty = 0;
          for (let o = 0; o < 8; o++) {
            if (counts[o] > 0) nonEmpty++;
          }
          if (nonEmpty > 1) {
            isLeaf = false;
            // prefix sums for offsets
            const offs = new Uint32Array(8);
            for (let o = 1; o < 8; o++) {
              offs[o] = offs[o - 1] + counts[o - 1];
            }
            const tmp = counts.slice(); // copy
            const packed = new Uint32Array(job.len);
            // pack into temp buffer
            for (let i = 0; i < job.len; i++) {
              const vi = indices[job.start + i] * 3;
              let oct = 0;
              if (p[vi]     > cx) oct |= 1;
              if (p[vi + 1] > cy) oct |= 2;
              if (p[vi + 2] > cz) oct |= 4;
              const pos = offs[oct] + (tmp[oct] - 1);
              packed[pos] = indices[job.start + i];
              tmp[oct]--;
            }
            // overwrite the region in indices
            for (let i = 0; i < job.len; i++) {
              indices[job.start + i] = packed[i];
            }
  
            // spawn child jobs for each nonempty octant
            for (let o = 0; o < 8; o++) {
              const cnt = counts[o];
              if (cnt === 0) continue;
              let childBox;
              if (cubic) {
                const minCx = minX + ((o & 1) ? hx : 0);
                const minCy = minY + ((o & 2) ? hy : 0);
                const minCz = minZ + ((o & 4) ? hz : 0);
                const maxCx = minX + ((o & 1) ? hx * 2 : hx);
                const maxCy = minY + ((o & 2) ? hy * 2 : hy);
                const maxCz = minZ + ((o & 4) ? hz * 2 : hz);
                childBox = [minCx, minCy, minCz, maxCx, maxCy, maxCz];
              } else {
                const childStart = job.start + offs[o];
                const subIdx = indices.subarray(childStart, childStart + cnt);
                childBox = computeAABB(p, s, r, subIdx, cnt);
              }
              stack.push(new OTJob(job.start + offs[o], cnt, childBox));
            }
          }
        }
  
        outBoxes.push(cx, cy, cz, hx, hy, hz);
        leafFlagsArr.push(isLeaf ? 1 : 0);
      }
  
      // flatten results into typed arrays
      const Nnodes = outBoxes.length / 6;
      const data = new Float32Array(Nnodes * 6);
      for (let i = 0; i < Nnodes * 6; i++) {
        data[i] = outBoxes[i];
      }
      const leafFlags = new Uint8Array(Nnodes);
      for (let i = 0; i < Nnodes; i++) {
        leafFlags[i] = leafFlagsArr[i];
      }
      const childL = new Int32Array(Nnodes);
      const childR = new Int32Array(Nnodes);
      for (let i = 0; i < Nnodes; i++) {
        childL[i] = -1;
        childR[i] = -1;
      }
  
      return { data, leafFlags, childL, childR };
    }
  
    /** Worker message handler */
    self.onmessage = function(e) {
      const { version, structure, minLeaf, pos, scl, rad, cubic, t0 } = e.data;
      
  const startTime = performance.now();
      
      if (structure === "bvh") {
        // Build BVH
        const result = buildBVH(pos, scl, rad, minLeaf);
        const Nnodes = result.data.length / 6;
        const data = result.data;
        const leafArr = result.leafFlags;
        const childL = result.childL;
        const childR = result.childR;
        const leafIdxs = result.leafIndices;
  
        // Prepare postMessage with transferable buffers
        self.postMessage(
          {
            version,
            buildTime: performance.now() - startTime,
            data,        // Float32Array(6 * Nnodes)
            leaf: leafArr,// Uint8Array(Nnodes)
            childL,      // Int32Array(Nnodes)
            childR,      // Int32Array(Nnodes)
            leafIdxs     // Array<Uint32Array>
          },
          [
            data.buffer,
            leafArr.buffer,
            childL.buffer,
            childR.buffer,
            ...leafIdxs.map(arr => arr.buffer)
          ]
        );
      } else {
        // Build Octree
        const result = buildOctree(pos, scl, rad, minLeaf, cubic);
        const Nnodes = result.data.length / 6;
        const data = result.data;
        const leafArr = result.leafFlags;
        const childL = result.childL;
        const childR = result.childR;
  
        self.postMessage(
          {
            version,
            buildTime: performance.now() - startTime,
            data,        // Float32Array(6 * Nnodes)
            leaf: leafArr,// Uint8Array(Nnodes)
            childL,      // Int32Array(Nnodes)
            childR,      // Int32Array(Nnodes)
            leafIdxs: [] // no leafIndices returned for this octree
          },
          [
            data.buffer,
            leafArr.buffer,
            childL.buffer,
            childR.buffer
          ]
        );
      }
    };
  </script>

  <!-- ────────────── /worker ────────────── -->

  <script src="https://cdn.jsdelivr.net/npm/babylonjs@6.39.0/babylon.js"></script>
  <script>
    /* ---------- Babylon scene ---------- */
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    scene.clearColor.set(0.9, 0.9, 0.95);

    const cam = new BABYLON.ArcRotateCamera(
      "cam", Math.PI / 4, Math.PI / 4, 300, BABYLON.Vector3.Zero(), scene
    );
    cam.attachControl(canvas, true);
    new BABYLON.HemisphericLight("L", new BABYLON.Vector3(0, 1, 0), scene)
      .intensity = 0.9;

    /* ---------- materials -------------------------------------------------- */
    const matLeaf = new BABYLON.StandardMaterial("leafM", scene);
    matLeaf.diffuseColor.set(0.1, 0.8, 0.1);
    matLeaf.alpha = 0.1;

    const matInt = new BABYLON.StandardMaterial("intM", scene);
    matInt.diffuseColor.set(1, 0, 0);
    matInt.alpha = 0.01;

    const matPt = new BABYLON.StandardMaterial("ptM", scene);
    matPt.diffuseColor.set(0, 0, 0.8);
    matPt.forceDepthWrite = true;
    matPt.backFaceCulling = false;

    const matHighlight = new BABYLON.StandardMaterial("highlightM", scene);
    matHighlight.diffuseColor.set(1, 1, 0); // yellow
    matHighlight.alpha = 1.0;              // fully opaque

    /* ---------- template meshes & rendering groups ------------------------- */
    const leafT = BABYLON.MeshBuilder.CreateBox("leafT", { size: 1 }, scene);
    leafT.material = matLeaf;
    leafT.setEnabled(false);
    leafT.renderingGroupId = 1;

    const intT = BABYLON.MeshBuilder.CreateBox("intT", { size: 1 }, scene);
    intT.material = matInt;
    intT.setEnabled(false);
    intT.renderingGroupId = 1;

    const ptT = BABYLON.MeshBuilder.CreateSphere("ptT", { diameter: 1 }, scene);
    ptT.material = matPt;
    ptT.setEnabled(false);
    ptT.renderingGroupId = 0;

    /* ---------- instancing helper ------------------------------------------- */
    const leafInst = [], intInst = [], ptInst = [];
    function ensure(arr, tmpl, n) {
      for (let i = arr.length; i < n; i++) {
        arr.push(tmpl.createInstance(tmpl.name + i));
      }
      for (let i = 0; i < arr.length; i++) {
        arr[i].setEnabled(i < n);
      }
    }

    /* ---------- point generator ------------------------------------------- */
    function genPoints(n) {
      const pos = new Float32Array(n * 3),
        scl = new Float32Array(n * 3),
        rad = new Float32Array(n);
      for (let i = 0; i < n; i++) {
        const o = i * 3;
        pos[o] = Math.random() * 200 - 100;
        pos[o + 1] = Math.random() * 200 - 100;
        pos[o + 2] = Math.random() * 200 - 100;
        scl[o] = scl[o + 1] = scl[o + 2] = 1;
        rad[i] = 1;
      }
      return { pos, scl, rad };
    }
    let currentPts = null;

    /* ---------- worker-pool ------------------------------------------------ */
    const workerURL = URL.createObjectURL(
      new Blob([document.getElementById("oct-worker").textContent],
        { type: "application/javascript" })
    );
    class WorkerPool {
      constructor(url, max = 8) {
        this.url = url;
        this.max = Math.min(max, navigator.hardwareConcurrency || 4);
        this.free = [...Array(this.max)].map(() => this.#spawn());
        this.queue = [];
      }
      #spawn() {
        const w = new Worker(this.url);
        w.onmessage = e => {
          w._cb?.(e);
          w._cb = null;
          this.free.push(w);
          this.#kick();
        };
        return w;
      }
      run(msg, cb) {
        this.queue.push({ msg, cb });
        this.#kick();
      }
      #kick() {
        if (!this.free.length || !this.queue.length) return;
        const { msg, cb } = this.queue.shift();
        const w = this.free.pop();
        w._cb = cb;
        msg.t0 = performance.now();
        w.postMessage(msg, [msg.pos.buffer, msg.scl.buffer, msg.rad.buffer]);
      }
    }
    const pool = new WorkerPool(workerURL, 8);
    const runWorker = (task, cb) => pool.run(task, cb);

    /* ---------- BVH data & leaf records ----------------------------------- */
    let nodeData = null;   // Float32Array: [cx, cy, cz, hx, hy, hz] × nodeCount
    let isLeafArr = null;   // Uint8Array: leaf=1 / internal=0
    let childLArr = null;   // Int32Array: left child index or -1
    let childRArr = null;   // Int32Array: right child index or -1
    let leafIndicesArray = null;   // Array<Uint32Array>: indices per leaf
    let leafNodesRecords = [];     // [{min:[x,y,z], max:[x,y,z], indices:Uint32Array, nodeIndex}, …]
    let highlightedLeafIndex = null;   // currently highlighted node index

    /* ---------- collision info table container ----------------------------- */
    const collisionDiv = document.getElementById("collisionTable");

    /* ---------- single “highlight box” (non-instanced) -------------------- */
    let highlightBoxMesh = null;

    /* ---------- UI & rebuild ---------------------------------------------- */
    const sel = document.getElementById("structure");
    const minIn = document.getElementById("minLeaf");
    const numIn = document.getElementById("numPts");
    const stats = document.getElementById("stats");
    document.getElementById("rebuild").onclick = rebuild;
    document.getElementById("shoot").onclick = shootBall;

    let version = 0;
    rebuild();

    function rebuild() {
      const n = +numIn.value;
      currentPts = genPoints(n);
      version++;

      const posCopy = new Float32Array(currentPts.pos);
      const sclCopy = new Float32Array(currentPts.scl);
      const radCopy = new Float32Array(currentPts.rad);

      runWorker({
        version,
        structure: sel.value,
        cubic: sel.value === "octCube",
        minLeaf: +minIn.value,
        pos: posCopy,
        scl: sclCopy,
        rad: radCopy
      }, e => {
        if (e.data.version !== version) return;  // ignore stale

        const { data, leaf, childL, childR, buildTime, leafIdxs } = e.data;
        const nodeCount = leaf.length;
        const nPts = currentPts.pos.length / 3;

        nodeData = data;           // Float32Array(6 * nodeCount)
        isLeafArr = leaf;           // Uint8Array(nodeCount)
        childLArr = childL;         // Int32Array(nodeCount)
        childRArr = childR;         // Int32Array(nodeCount)
        leafIndicesArray = leafIdxs;       // Array<Uint32Array>

        // Build leafNodesRecords (with nodeIndex)
        leafNodesRecords = [];
        let leafCounter = 0;
        for (let i = 0; i < nodeCount; i++) {
          if (isLeafArr[i] === 1) {
            const d = i * 6;
            const cx = nodeData[d], cy = nodeData[d + 1], cz = nodeData[d + 2];
            const hx = nodeData[d + 3], hy = nodeData[d + 4], hz = nodeData[d + 5];
            const minX = cx - hx, minY = cy - hy, minZ = cz - hz;
            const maxX = cx + hx, maxY = cy + hy, maxZ = cz + hz;
            leafNodesRecords.push({
              min: [minX, minY, minZ],
              max: [maxX, maxY, maxZ],
              indices: leafIndicesArray[leafCounter++] || new Uint32Array(),
              nodeIndex: i
            });
          }
        }

        // Dispose old highlight box
        if (highlightBoxMesh) {
          highlightBoxMesh.dispose();
          highlightBoxMesh = null;
        }
        highlightedLeafIndex = null;

        // Populate point cloud
        ensure(ptInst, ptT, nPts);
        for (let i = 0; i < nPts; i++) {
          const m = ptInst[i];
          const b = i * 3;
          m.position.set(
            currentPts.pos[b],
            currentPts.pos[b + 1],
            currentPts.pos[b + 2]
          );
          m.scaling.set(2, 2, 2);
        }

        // Populate BVH cubes (leaf and internal)
        let leafCnt = 0, intCnt = 0;
        for (const f of isLeafArr) {
          if (f) leafCnt++;
          else intCnt++;
        }
        ensure(leafInst, leafT, leafCnt);
        ensure(intInst, intT, intCnt);

        let li = 0, ii = 0;
        for (let i = 0; i < nodeCount; i++) {
          const d = i * 6;
          const cx = nodeData[d], cy = nodeData[d + 1], cz = nodeData[d + 2];
          const hx = nodeData[d + 3], hy = nodeData[d + 4], hz = nodeData[d + 5];
          const inst = isLeafArr[i] ? leafInst[li++] : intInst[ii++];
          inst.position.set(cx, cy, cz);
          inst.scaling.set(hx * 2, hy * 2, hz * 2);
        }

        stats.textContent =
          `Nodes: ${nodeCount.toLocaleString()}  |  Build ${buildTime.toFixed(2)} ms`;

        collisionDiv.innerHTML = "";
      });
    }

    /* ---------- Ball & Collision Logic ------------------------------------ */
    let ballMesh = null;
    let ballVelocity = new BABYLON.Vector3();
    const ballSpeed = 200;          // units/sec
    const ballRadius = 2;            // sphere diameter=4
    let isBallActive = false;
    let ballSpawnTime = 0;
    const ballMaxLifetime = 5000;     // ms

    function shootBall() {
      if (!nodeData) {
        console.warn("BVH not built yet. Rebuild and try again.");
        return;
      }

      // Dispose old ball
      if (ballMesh) {
        ballMesh.dispose();
        isBallActive = false;
      }

      // Create new ball at camera
      const camPos = cam.position.clone();
      ballMesh = BABYLON.MeshBuilder.CreateSphere("ball", { diameter: ballRadius * 2 }, scene);
      ballMesh.position.copyFrom(camPos);
      ballMesh.material = new BABYLON.StandardMaterial("ballMat", scene);
      ballMesh.material.diffuseColor.set(0.8, 0.2, 0.2);
      ballMesh.renderingGroupId = 0;

      // Direction from camera to target
      const dir = cam.target.clone().subtract(camPos).normalize();
      ballVelocity = dir.scale(ballSpeed);

      ballSpawnTime = performance.now();
      isBallActive = true;

      // Clear previous info/highlight
      collisionDiv.innerHTML = "";
      if (highlightBoxMesh) {
        highlightBoxMesh.dispose();
        highlightBoxMesh = null;
        highlightedLeafIndex = null;
      }
    }

    scene.registerBeforeRender(() => {
      if (!isBallActive || !ballMesh) return;

      const now = performance.now();
      if (now - ballSpawnTime >= ballMaxLifetime) {
        ballMesh.dispose();
        isBallActive = false;
        return;
      }

      const delta = engine.getDeltaTime() / 1000;
      ballMesh.position.addInPlace(ballVelocity.scale(delta));

      console.time("Tree Traversal");
      // --- Find collided leaf (O(#leaves)) ---
      let collidedLeafRecord = null;
      for (const rec of leafNodesRecords) {
        const [minX, minY, minZ] = rec.min;
        const [maxX, maxY, maxZ] = rec.max;
        if (
          ballMesh.position.x >= minX && ballMesh.position.x <= maxX &&
          ballMesh.position.y >= minY && ballMesh.position.y <= maxY &&
          ballMesh.position.z >= minZ && ballMesh.position.z <= maxZ
        ) {
          collidedLeafRecord = rec;
          break;
        }
      }
      if (!collidedLeafRecord) {
        // Not yet inside any leaf
        console.timeEnd("Tree Traversal");
        return;
      }

      const collidedLeafNodeIndex = collidedLeafRecord.nodeIndex;

      // --- Check particles in that leaf for actual collision ---
      const indices = collidedLeafRecord.indices;
      let particleHit = -1;
      const pxArr = currentPts.pos;
      const prArr = currentPts.rad;
      const pos = ballMesh.position;
      for (let i = 0; i < indices.length; i++) {
        const idx = indices[i];
        const px = pxArr[3 * idx];
        const py = pxArr[3 * idx + 1];
        const pz = pxArr[3 * idx + 2];
        const dx = pos.x - px;
        const dy = pos.y - py;
        const dz = pos.z - pz;
        const distSq = dx * dx + dy * dy + dz * dz;
        const radiusSum = ballRadius + prArr[idx];
        if (distSq <= radiusSum * radiusSum) {
          particleHit = idx;
          break;
        }
      }
      console.timeEnd("Tree Traversal");
      if (particleHit < 0) {
        // No orb‐collision yet; continue traveling
        // Optionally highlight current leaf
        if (highlightBoxMesh && highlightedLeafIndex !== collidedLeafNodeIndex) {
          highlightBoxMesh.dispose();
          highlightBoxMesh = null;
        }
        if (!highlightBoxMesh || highlightedLeafIndex !== collidedLeafNodeIndex) {
          const d = collidedLeafNodeIndex * 6;
          const cx = nodeData[d], cy = nodeData[d + 1], cz = nodeData[d + 2];
          const hx = nodeData[d + 3], hy = nodeData[d + 4], hz = nodeData[d + 5];
          highlightBoxMesh = BABYLON.MeshBuilder.CreateBox(
            "highlightBox",
            { width: hx * 2, height: hy * 2, depth: hz * 2 },
            scene
          );
          highlightBoxMesh.position.set(cx, cy, cz);
          highlightBoxMesh.material = matHighlight;
          highlightBoxMesh.renderingGroupId = 1;
          highlightedLeafIndex = collidedLeafNodeIndex;
        }
        return;
      }

      // --- Actual orb collision occurred! Build hierarchy path (O(depth)) ---
      function collectHierarchy(point) {
        const path = [];
        function recurse(nodeIndex) {
          path.push(nodeIndex);
          if (isLeafArr[nodeIndex] === 0) {
            const L = childLArr[nodeIndex];
            if (L >= 0) {
              const ld = L * 6;
              const lcX = nodeData[ld], lcY = nodeData[ld + 1], lcZ = nodeData[ld + 2];
              const lhX = nodeData[ld + 3], lhY = nodeData[ld + 4], lhZ = nodeData[ld + 5];
              if (
                point.x >= lcX - lhX && point.x <= lcX + lhX &&
                point.y >= lcY - lhY && point.y <= lcY + lhY &&
                point.z >= lcZ - lhZ && point.z <= lcZ + lhZ
              ) {
                recurse(L);
                return;
              }
            }
            const R = childRArr[nodeIndex];
            if (R >= 0) {
              const rd = R * 6;
              const rcX = nodeData[rd], rcY = nodeData[rd + 1], rcZ = nodeData[rd + 2];
              const rhX = nodeData[rd + 3], rhY = nodeData[rd + 4], rhZ = nodeData[rd + 5];
              if (
                point.x >= rcX - rhX && point.x <= rcX + rhX &&
                point.y >= rcY - rhY && point.y <= rcY + rhY &&
                point.z >= rcZ - rhZ && point.z <= rcZ + rhZ
              ) {
                recurse(R);
                return;
              }
            }
          }
        }
        recurse(0);
        return path;
      }

      const hierarchyPath = collectHierarchy(ballMesh.position);

      // --- Build HTML table from hierarchyPath ---
      let html = `
        <table border="1" cellpadding="4" style="width:100%; text-align:center;">
          <tr><th>Node Index</th></tr>
      `;
      hierarchyPath.forEach(idx => {
        html += `<tr data-node="${idx}"><td>${idx}</td></tr>`;
      });
      html += `</table>`;
      collisionDiv.innerHTML = html;

      // --- Attach hover listeners to rows ---
      const rows = collisionDiv.querySelectorAll("tr[data-node]");
      rows.forEach(row => {
        const nodeIdx = parseInt(row.getAttribute("data-node"));
        row.addEventListener("mouseenter", () => {
          if (highlightBoxMesh && highlightedLeafIndex !== nodeIdx) {
            highlightBoxMesh.dispose();
            highlightBoxMesh = null;
          }
          if (!highlightBoxMesh || highlightedLeafIndex !== nodeIdx) {
            const d = nodeIdx * 6;
            const cx = nodeData[d], cy = nodeData[d + 1], cz = nodeData[d + 2];
            const hx = nodeData[d + 3], hy = nodeData[d + 4], hz = nodeData[d + 5];
            highlightBoxMesh = BABYLON.MeshBuilder.CreateBox(
              "highlightBox",
              { width: hx * 2, height: hy * 2, depth: hz * 2 },
              scene
            );
            highlightBoxMesh.position.set(cx, cy, cz);
            highlightBoxMesh.material = matHighlight;
            highlightBoxMesh.renderingGroupId = 1;
            highlightedLeafIndex = nodeIdx;
          }
          row.classList.add("highlighted");
        });
        row.addEventListener("mouseleave", () => {
          // Revert to collided leaf highlight
          if (highlightBoxMesh && highlightedLeafIndex !== collidedLeafNodeIndex) {
            highlightBoxMesh.dispose();
            highlightBoxMesh = null;
          }
          if (!highlightBoxMesh || highlightedLeafIndex !== collidedLeafNodeIndex) {
            const d = collidedLeafNodeIndex * 6;
            const cx = nodeData[d], cy = nodeData[d + 1], cz = nodeData[d + 2];
            const hx = nodeData[d + 3], hy = nodeData[d + 4], hz = nodeData[d + 5];
            highlightBoxMesh = BABYLON.MeshBuilder.CreateBox(
              "highlightBox",
              { width: hx * 2, height: hy * 2, depth: hz * 2 },
              scene
            );
            highlightBoxMesh.position.set(cx, cy, cz);
            highlightBoxMesh.material = matHighlight;
            highlightBoxMesh.renderingGroupId = 1;
            highlightedLeafIndex = collidedLeafNodeIndex;
          }
          row.classList.remove("highlighted");
        });
      });

      // Destroy the ball
      ballMesh.dispose();
      isBallActive = false;
    });

    /* ---------- render loop ---------------------------------------------- */
    engine.runRenderLoop(() => scene.render());
    window.addEventListener("resize", () => engine.resize());
  </script>
</body>

</html>
