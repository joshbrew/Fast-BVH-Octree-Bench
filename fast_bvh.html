<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>BVH / Octree + Worker Pool with Super‐Fast Tree Traversal</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #dfe8ff;
    }

    #renderCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #ui {
      position: absolute;
      top: 8px;
      left: 8px;
      background: #ffffffe0;
      padding: 8px 12px;
      border-radius: 8px;
      font: 13px/1.4 sans-serif;
      box-shadow: 0 2px 6px #0004;
      z-index: 10;
    }

    #ui label {
      display: block;
      margin-top: 4px;
    }

    /* Collision table styling */
    #collisionTable {
      position: absolute;
      bottom: 8px;
      left: 8px;
      width: 200px;
      background: #ffffffcc;
      padding: 8px;
      border: 1px solid #888;
      max-height: 250px;
      overflow-y: auto;
      font-size: 12px;
      z-index: 10;
    }

    /* Table row pointer */
    #collisionTable tr[data-node] {
      cursor: pointer;
    }

    /* Highlighted row background */
    #collisionTable tr.highlighted {
      background-color: #ffff99;
    }
  </style>
</head>

<body>
  <canvas id="renderCanvas"></canvas>

  <div id="ui">
    <label>Structure:
      <select id="structure">
        <option value="bvh">BVH (adaptive AABB)</option>
        <option value="oct">Octree (adaptive AABB)</option>
        <option value="octCube">Octree (cubic)</option>
      </select>
    </label>
    <label>Min entities / leaf:
      <input id="minLeaf" type="number" value="6" min="1" max="256" step="1">
    </label>
    <label>Point count:
      <input id="numPts" type="number" value="10000" min="100" max="200000" step="1000">
    </label>
    <button id="rebuild">Re-build</button>
    <button id="shoot">Shoot Ball</button>
    <div id="stats" style="margin-top:6px;font-size:12px"></div>
  </div>

  <div id="collisionTable"></div>

  <!-- ────────────── WORKER CODE (inline) ────────────── -->
  <script id="oct-worker" type="javascript/worker">
    // ──────────────────────────────────────────────────────────────────────────
    // Worker‐only code: only one `self.onmessage = function(e) { … }` block!
    // ──────────────────────────────────────────────────────────────────────────
  
    const EPS = Number.EPSILON;
  
    /** Compute AABB over a subset of points */
    function computeAABB(p, s, r, idx, len) {
      let xmin =  1e9, ymin =  1e9, zmin =  1e9;
      let xmax = -1e9, ymax = -1e9, zmax = -1e9;
      for (let i = 0; i < len; i++) {
        const vi = idx[i] * 3;
        const x = p[vi],     y = p[vi + 1],   z = p[vi + 2];
        const sx = s[vi],    sy = s[vi + 1],  sz = s[vi + 2];
        const rad = r[idx[i]] || EPS;
  
        const minx = x - rad * sx, maxx = x + rad * sx;
        const miny = y - rad * sy, maxy = y + rad * sy;
        const minz = z - rad * sz, maxz = z + rad * sz;
  
        if (minx < xmin) xmin = minx;
        if (maxx > xmax) xmax = maxx;
        if (miny < ymin) ymin = miny;
        if (maxy > ymax) ymax = maxy;
        if (minz < zmin) zmin = minz;
        if (maxz > zmax) zmax = maxz;
      }
      return [xmin, ymin, zmin, xmax, ymax, zmax];
    }
  
    /**
    * Build a BVH over points, guaranteeing that no leaf contains more than `minLeaf` points,
    * but using quickselect+partition instead of full sort to keep it fast.
    *
    * p:   Float32Array of length 3*N  (xyz,x y z, …)
    * s:   Float32Array of length 3*N  (per‐axis scale, not used for splitting)
    * r:   Float32Array of length N    (radius per point, not used for splitting)
    * minLeaf: maximum number of points you allow in any leaf
    *
    * Returns { data, leafFlags, childL, childR, leafIndices } exactly as before.
    */
   function buildBVH(p, s, r, minLeaf) {
     const N = p.length / 3;
     if (N === 0) {
       return {
         data: new Float32Array(0),
         leafFlags: new Uint8Array(0),
         childL: new Int32Array(0),
         childR: new Int32Array(0),
         leafIndices: []
       };
     }
   
     // 1) Create a single “master” index buffer [0,1,2,…,N-1]
     const indices = new Uint32Array(N);
     for (let i = 0; i < N; i++) {
       indices[i] = i;
     }
   
     // Helper: swap two entries of `indices`
     function swap(a, i, j) {
       const tmp = a[i];
       a[i] = a[j];
       a[j] = tmp;
     }
   
     /**
      * Partition the subarray indices[p..r] around pivotValue along coordinate `axis`.
      * All points ≤ pivotValue go to the left side of the returned pivot index. Returns pivotIndex.
      */
     function partitionAxis(a, p, r, axis, pivotValue) {
       let store = p;
       for (let i = p; i < r; i++) {
         // compare coordinate of a[i] on chosen axis
         if (pDigit(a[i], axis) < pivotValue) {
           swap(a, store, i);
           store++;
         }
       }
       // Finally move pivot to its final place
       return store;
     }
   
     /**
      * Return the coordinate of index `idx` in the flat Float32Array `p` along axis (0=x, 1=y, 2=z).
      */
     function pDigit(idx, axis) {
       return p[idx * 3 + axis];
     }
   
     /**
      * Quickselect on indices[p..r-1], looking for the element whose coordinate on `axis`
      * is the k-th smallest.  After this finishes, indices[p..p+k] are ≤ that pivot value,
      * and pivot is placed at indices[p+k].
      */
     function quickselect(a, p, r, k, axis) {
       while (true) {
         if (p + 1 >= r) return;
         // Choose a random pivot index between p and r-1
         const pivotIdx = p + ((r - p) >>> 1); // you can also randomize if you like
         const pivotValue = pDigit(a[pivotIdx], axis);
   
         // Partition around pivotValue
         let store = p;
         let storeEq = r;
         let i = p;
         while (i < storeEq) {
           const v = pDigit(a[i], axis);
           if (v < pivotValue) {
             swap(a, store, i);
             store++;
             i++;
           } else if (v > pivotValue) {
             storeEq--;
             swap(a, storeEq, i);
           } else {
             i++;
           }
         }
         // Now [p..store) < pivotValue, [store..storeEq) === pivotValue, [storeEq..r) > pivotValue
         if (k < store - p) {
           // target is in the “less than” region
           r = store;
         } else if (k < storeEq - p) {
           // pivot position is exactly p + k
           return;
         } else {
           // target is in the “greater than” region
           k = k - (storeEq - p);
           p = storeEq;
         }
       }
     }
   
     // Job descriptor for the iterative stack
     function JobBVH(start, len, parentIndex, isLeft) {
       this.start = start;       // start in `indices`
       this.len = len;           // number of points in this node
       this.parentIndex = parentIndex;
       this.isLeft = isLeft;     // if it's left child of its parent
       this.leaf = false;
       this.nodeIndex = -1;
     }
   
     const jobList = [];
     const stack = [ new JobBVH(0, N, -1, false) ];
   
     // 2) First pass: collect all jobs and partition in-place without full sort
     while (stack.length > 0) {
       const job = stack.pop();
       jobList.push(job);
   
       const currStart = job.start;
       const currLen = job.len;
   
       // If there are ≤ minLeaf points, make this node a leaf
       if (currLen <= minLeaf) {
         job.leaf = true;
         continue;
       }
   
       // Compute this node’s AABB to decide which axis to split
       let xmin = 1e9, ymin = 1e9, zmin = 1e9;
       let xmax = -1e9, ymax = -1e9, zmax = -1e9;
       for (let i = 0; i < currLen; i++) {
         const vi = indices[currStart + i] * 3;
         const x = p[vi], y = p[vi + 1], z = p[vi + 2];
         const sx = s[vi], sy = s[vi + 1], sz = s[vi + 2];
         const rad = r[indices[currStart + i]] || EPS;
         const minx = x - rad * sx, maxx = x + rad * sx;
         const miny = y - rad * sy, maxy = y + rad * sy;
         const minz = z - rad * sz, maxz = z + rad * sz;
         if (minx < xmin) xmin = minx;
         if (maxx > xmax) xmax = maxx;
         if (miny < ymin) ymin = miny;
         if (maxy > ymax) ymax = maxy;
         if (minz < zmin) zmin = minz;
         if (maxz > zmax) zmax = maxz;
       }
       const cx = 0.5 * (xmin + xmax),
             cy = 0.5 * (ymin + ymax),
             cz = 0.5 * (zmin + zmax);
       const hx = 0.5 * (xmax - xmin),
             hy = 0.5 * (ymax - ymin),
             hz = 0.5 * (zmax - zmin);
   
       // Choose axis of largest extent
       let axis = (hx * 2 >= hy * 2 ? 0 : 1);
       if (hz * 2 > (axis === 0 ? hx * 2 : hy * 2)) {
         axis = 2;
       }
   
       // 2a) Quickselect to find the median coordinate along `axis`
       const k = Math.floor(currLen / 2);
       quickselect(indices, currStart, currStart + currLen, k, axis);
   
       // Now indices[currStart .. currStart+k-1] are ≤ median,
       // indices[currStart+k] is one of the medians, and the rest ≥ median.
       // We will split exactly at `k`.
       job.leaf = false;
       const leftCount = k;
       const rightCount = currLen - k;
   
       // Push right child first, then left child
       stack.push(new JobBVH(
         currStart + leftCount,
         rightCount,
         jobList.length - 1,
         false
       ));
       stack.push(new JobBVH(
         currStart,
         leftCount,
         jobList.length - 1,
         true
       ));
     }
   
     // 3) Assign nodeIndex to each job
     const Nnodes = jobList.length;
     for (let i = 0; i < Nnodes; i++) {
       jobList[i].nodeIndex = i;
     }
   
     // 4) Allocate output arrays
     const data       = new Float32Array(Nnodes * 6);    // [cx, cy, cz, hx, hy, hz] × Nnodes
     const leafFlags  = new Uint8Array(Nnodes);          // 1 if leaf, 0 if internal
     const childL     = new Int32Array(Nnodes);          // left child index or -1
     const childR     = new Int32Array(Nnodes);          // right child index or -1
     const leafIndices = [];                              // one Uint32Array per leaf
   
     // Initialize all children to -1
     for (let i = 0; i < Nnodes; i++) {
       childL[i] = -1;
       childR[i] = -1;
     }
   
     // 5) Second pass: fill in AABB, leaf flags, child pointers, and leaf‐index lists
     for (let i = 0; i < Nnodes; i++) {
       const job = jobList[i];
       const start = job.start;
       const len   = job.len;
       const subIdx = indices.subarray(start, start + len);
   
       // Compute this node's final AABB
       let xmin = 1e9, ymin = 1e9, zmin = 1e9;
       let xmax = -1e9, ymax = -1e9, zmax = -1e9;
       for (let j = 0; j < len; j++) {
         const vi = subIdx[j] * 3;
         const x = p[vi],     y = p[vi + 1],   z = p[vi + 2];
         const sx = s[vi],    sy = s[vi + 1],  sz = s[vi + 2];
         const rad = r[subIdx[j]] || EPS;
         const minx = x - rad * sx, maxx = x + rad * sx;
         const miny = y - rad * sy, maxy = y + rad * sy;
         const minz = z - rad * sz, maxz = z + rad * sz;
         if (minx < xmin) xmin = minx;
         if (maxx > xmax) xmax = maxx;
         if (miny < ymin) ymin = miny;
         if (maxy > ymax) ymax = maxy;
         if (minz < zmin) zmin = minz;
         if (maxz > zmax) zmax = maxz;
       }
       const cx = 0.5 * (xmin + xmax),
             cy = 0.5 * (ymin + ymax),
             cz = 0.5 * (zmin + zmax);
       const hx = 0.5 * (xmax - xmin),
             hy = 0.5 * (ymax - ymin),
             hz = 0.5 * (zmax - zmin);
   
       const offset = i * 6;
       data[offset]     = cx;
       data[offset + 1] = cy;
       data[offset + 2] = cz;
       data[offset + 3] = hx;
       data[offset + 4] = hy;
       data[offset + 5] = hz;
   
       leafFlags[i] = job.leaf ? 1 : 0;
       if (job.leaf) {
         // Exactly those ≤ minLeaf point‐indices go into one Leaf
         leafIndices.push(new Uint32Array(subIdx));
       }
   
       // Attach this node to its parent
       if (job.parentIndex >= 0) {
         const pIdx = job.parentIndex;
         const parentNodeIndex = jobList[pIdx].nodeIndex;
         if (job.isLeft) {
           childL[parentNodeIndex] = job.nodeIndex;
         } else {
           childR[parentNodeIndex] = job.nodeIndex;
         }
       }
     }
   
     return { data, leafFlags, childL, childR, leafIndices };
   }
   

    
  
    /**
     * Build a (pointer‐free) Octree over points, guaranteeing each leaf ≤ minLeaf.
     * If `cubic` is true, the root node is forced into a cube.
     * Returns { data, leafFlags, childL, childR, leafIndices, childrenIdxs }.
     */
    function buildOctree(p, s, r, minLeaf, cubic) {
      const N = p.length / 3;
      if (N === 0) {
        return {
          data: new Float32Array(0),
          leafFlags: new Uint8Array(0),
          childL: new Int32Array(0),
          childR: new Int32Array(0),
          leafIndices: [],
          childrenIdxs: []
        };
      }
  
      // 1) Master index buffer [0,1,2,...]
      const indices = new Uint32Array(N);
      for (let i = 0; i < N; i++) indices[i] = i;
  
      // Compute root AABB
      let rootBox = computeAABB(p, s, r, indices, N);
      if (cubic) {
        const sizeX = rootBox[3] - rootBox[0];
        const sizeY = rootBox[4] - rootBox[1];
        const sizeZ = rootBox[5] - rootBox[2];
        const size = Math.max(sizeX, sizeY, sizeZ);
        const cx = 0.5 * (rootBox[0] + rootBox[3]);
        const cy = 0.5 * (rootBox[1] + rootBox[4]);
        const cz = 0.5 * (rootBox[2] + rootBox[5]);
        rootBox = [
          cx - 0.5 * size, cy - 0.5 * size, cz - 0.5 * size,
          cx + 0.5 * size, cy + 0.5 * size, cz + 0.5 * size
        ];
      }
  
      // OTJob descriptor
      function JobOT(start, len, box, parentIndex) {
        this.start = start;
        this.len = len;
        this.box = box;              // [minX,minY,minZ,maxX,maxY,maxZ]
        this.parentIndex = parentIndex;
        this.nodeIndex = -1;         // assigned in pass 2
        this.leaf = false;
      }
  
      const jobList = [];
      const stack = [ new JobOT(0, N, rootBox, -1) ];
      const counts = new Uint32Array(8);
  
      // 2) Pass 1: collect all jobs, partition in‐place
      while (stack.length > 0) {
        const job = stack.pop();
        jobList.push(job);
  
        const [minX, minY, minZ, maxX, maxY, maxZ] = job.box;
        const cx = 0.5 * (minX + maxX);
        const cy = 0.5 * (minY + maxY);
        const cz = 0.5 * (minZ + maxZ);
        const hx = 0.5 * (maxX - minX);
        const hy = 0.5 * (maxY - minY);
        const hz = 0.5 * (maxZ - minZ);
  
        let isLeaf = true;
        if (job.len > minLeaf) {
          // Count how many points fall into each of 8 octants
          counts.fill(0);
          for (let i = 0; i < job.len; i++) {
            const vi = indices[job.start + i] * 3;
            let oct = 0;
            if (p[vi]     > cx) oct |= 1;
            if (p[vi + 1] > cy) oct |= 2;
            if (p[vi + 2] > cz) oct |= 4;
            counts[oct]++;
          }
          let nonEmpty = 0;
          for (let o = 0; o < 8; o++) {
            if (counts[o] > 0) nonEmpty++;
          }
          if (nonEmpty > 1) {
            isLeaf = false;
  
            // Prefix sums → offs[]
            const offs = new Uint32Array(8);
            for (let o = 1; o < 8; o++) {
              offs[o] = offs[o - 1] + counts[o - 1];
            }
            const tmp = counts.slice();
            const packed = new Uint32Array(job.len);
  
            // Pack points by octant
            for (let i = 0; i < job.len; i++) {
              const vi = indices[job.start + i] * 3;
              let oct = 0;
              if (p[vi]     > cx) oct |= 1;
              if (p[vi + 1] > cy) oct |= 2;
              if (p[vi + 2] > cz) oct |= 4;
              const pos = offs[oct] + (tmp[oct] - 1);
              packed[pos] = indices[job.start + i];
              tmp[oct]--;
            }
            // Overwrite in the master indices buffer
            for (let i = 0; i < job.len; i++) {
              indices[job.start + i] = packed[i];
            }
  
            // Spawn a child job for each non‐empty octant
            for (let o = 0; o < 8; o++) {
              const cnt = counts[o];
              if (cnt === 0) continue;
  
              let childBox;
              if (cubic) {
                // Subdivide parent cube equally
                const minCx = minX + ((o & 1) ? hx : 0);
                const minCy = minY + ((o & 2) ? hy : 0);
                const minCz = minZ + ((o & 4) ? hz : 0);
                const maxCx = minX + ((o & 1) ? hx * 2 : hx);
                const maxCy = minY + ((o & 2) ? hy * 2 : hy);
                const maxCz = minZ + ((o & 4) ? hz * 2 : hz);
                childBox = [minCx, minCy, minCz, maxCx, maxCy, maxCz];
              } else {
                // Non‐cubic: recompute AABB from actual points in that octant
                const childStart = job.start + offs[o];
                const subIdx = indices.subarray(childStart, childStart + cnt);
                childBox = computeAABB(p, s, r, subIdx, cnt);
              }
  
              stack.push(new JobOT(job.start + offs[o], cnt, childBox, jobList.length - 1));
            }
          }
        }
  
        job.leaf = isLeaf;
      }
  
      // 3) Assign nodeIndex for each job
      const Nnodes = jobList.length;
      for (let i = 0; i < Nnodes; i++) {
        jobList[i].nodeIndex = i;
      }
  
      // 4) Build childrenIdxs (array of up to 8 child‐indices per node)
      const childrenIndices = new Array(Nnodes);
      for (let i = 0; i < Nnodes; i++) {
        childrenIndices[i] = [];
      }
      for (let i = 0; i < Nnodes; i++) {
        const job = jobList[i];
        if (job.parentIndex >= 0) {
          childrenIndices[job.parentIndex].push(job.nodeIndex);
        }
      }
      const childrenIdxs = childrenIndices.map(arr => new Uint32Array(arr));
  
      // 5) Allocate output buffers
      const outBoxes = [];       // flattened [cx,cy,cz,hx,hy,hz,…]
      const leafFlagsArr = [];   // 1 or 0
      const leafIndicesArr = []; // array of Uint32Array for each leaf
      const childL = new Int32Array(Nnodes);
      const childR = new Int32Array(Nnodes);
      for (let i = 0; i < Nnodes; i++) {
        childL[i] = -1;
        childR[i] = -1;
      }
  
      // 6) Pass 2: fill in outBoxes, leafFlagsArr, and leafIndicesArr
      while (outBoxes.length < Nnodes * 6) {
        const i = outBoxes.length / 6;
        const job = jobList[i];
        const [minX, minY, minZ, maxX, maxY, maxZ] = job.box;
        const cx = 0.5 * (minX + maxX);
        const cy = 0.5 * (minY + maxY);
        const cz = 0.5 * (minZ + maxZ);
        const hx = 0.5 * (maxX - minX);
        const hy = 0.5 * (maxY - minY);
        const hz = 0.5 * (maxZ - minZ);
  
        outBoxes.push(cx, cy, cz, hx, hy, hz);
        leafFlagsArr.push(job.leaf ? 1 : 0);
  
        if (job.leaf) {
          const subIdx = indices.subarray(job.start, job.start + job.len);
          leafIndicesArr.push(new Uint32Array(subIdx));
        }
      }
  
      // Flatten outBoxes into a Float32Array
      const data = new Float32Array(Nnodes * 6);
      for (let i = 0; i < Nnodes * 6; i++) {
        data[i] = outBoxes[i];
      }
      const leafFlags = new Uint8Array(Nnodes);
      for (let i = 0; i < Nnodes; i++) {
        leafFlags[i] = leafFlagsArr[i];
      }
  
      return {
        data,
        leafFlags,
        childL,
        childR,
        leafIndices: leafIndicesArr,
        childrenIdxs
      };
    }
  
    /** Finally: the single worker‐message handler—only one of these! */
    self.onmessage = function(e) {
      const { version, structure, minLeaf, pos, scl, rad, cubic } = e.data;
      const startTime = performance.now();
  
      if (structure === "bvh") {
        const result = buildBVH(pos, scl, rad, minLeaf);
        const { data, leafFlags, childL, childR, leafIndices } = result;
        self.postMessage(
          {
            version,
            buildTime: performance.now() - startTime,
            data,           // Float32Array
            leaf: leafFlags, // Uint8Array
            childL,         // Int32Array
            childR,         // Int32Array
            leafIdxs: leafIndices // Array<Uint32Array>
          },
          [
            data.buffer,
            leafFlags.buffer,
            childL.buffer,
            childR.buffer,
            ...leafIndices.map(arr => arr.buffer)
          ]
        );
  
      } else {
        const result = buildOctree(pos, scl, rad, minLeaf, cubic);
        const { data, leafFlags, childrenIdxs, leafIndices } = result;
        self.postMessage(
          {
            version,
            buildTime: performance.now() - startTime,
            data,            // Float32Array
            leaf: leafFlags, // Uint8Array
            childrenIdxs,    // Array<Uint32Array>
            leafIdxs: leafIndices  // Array<Uint32Array>
          },
          [
            data.buffer,
            leafFlags.buffer,
            ...childrenIdxs.map(arr => arr.buffer),
            ...leafIndices.map(arr => arr.buffer)
          ]
        );
      }
    };
  </script>


  <!-- ────────────── /worker ────────────── -->
<script src="https://cdn.jsdelivr.net/npm/babylonjs@6.39.0/babylon.js"></script>
<script>
  /* ---------- Babylon scene ---------- */
  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true);
  const scene = new BABYLON.Scene(engine);
  scene.clearColor.set(0.9, 0.9, 0.95);

  const cam = new BABYLON.ArcRotateCamera(
    "cam", Math.PI / 4, Math.PI / 4, 300, BABYLON.Vector3.Zero(), scene
  );
  cam.attachControl(canvas, true);
  new BABYLON.HemisphericLight("L", new BABYLON.Vector3(0, 1, 0), scene)
    .intensity = 0.9;

  /* ---------- materials -------------------------------------------------- */
  const matLeaf = new BABYLON.StandardMaterial("leafM", scene);
  matLeaf.diffuseColor.set(0.1, 0.8, 0.1);
  matLeaf.alpha = 0.1;

  const matInt = new BABYLON.StandardMaterial("intM", scene);
  matInt.diffuseColor.set(1, 0, 0);
  matInt.alpha = 0.01;

  const matPt = new BABYLON.StandardMaterial("ptM", scene);
  matPt.diffuseColor.set(0, 0, 0.8);
  matPt.forceDepthWrite = true;
  matPt.backFaceCulling = false;

  const matHighlight = new BABYLON.StandardMaterial("highlightM", scene);
  matHighlight.diffuseColor.set(1, 1, 0); // yellow
  matHighlight.alpha = 1.0;              // fully opaque

  /* ---------- template meshes & rendering groups ------------------------- */
  const leafT = BABYLON.MeshBuilder.CreateBox("leafT", { size: 1 }, scene);
  leafT.material = matLeaf;
  leafT.setEnabled(false);
  leafT.renderingGroupId = 1;

  const intT = BABYLON.MeshBuilder.CreateBox("intT", { size: 1 }, scene);
  intT.material = matInt;
  intT.setEnabled(false);
  intT.renderingGroupId = 1;

  const ptT = BABYLON.MeshBuilder.CreateSphere("ptT", { diameter: 1 }, scene);
  ptT.material = matPt;
  ptT.setEnabled(false);
  ptT.renderingGroupId = 0;

  /* ---------- instancing helper ------------------------------------------- */
  const leafInst = [], intInst = [], ptInst = [];
  function ensure(arr, tmpl, n) {
    for (let i = arr.length; i < n; i++) {
      arr.push(tmpl.createInstance(tmpl.name + i));
    }
    for (let i = 0; i < arr.length; i++) {
      arr[i].setEnabled(i < n);
    }
  }

  /* ---------- point generator ------------------------------------------- */
  function genPoints(n) {
    const pos = new Float32Array(n * 3),
      scl = new Float32Array(n * 3),
      rad = new Float32Array(n);
    for (let i = 0; i < n; i++) {
      const o = i * 3;
      pos[o] = Math.random() * 200 - 100;
      pos[o + 1] = Math.random() * 200 - 100;
      pos[o + 2] = Math.random() * 200 - 100;
      scl[o] = scl[o + 1] = scl[o + 2] = 1;
      rad[i] = 1;
    }
    return { pos, scl, rad };
  }
  let currentPts = null;

  /* ---------- worker-pool ------------------------------------------------ */
  const workerURL = URL.createObjectURL(
    new Blob([document.getElementById("oct-worker").textContent],
      { type: "application/javascript" })
  );
  class WorkerPool {
    constructor(url, max = 8) {
      this.url = url;
      this.max = Math.min(max, navigator.hardwareConcurrency || 4);
      this.free = [...Array(this.max)].map(() => this.#spawn());
      this.queue = [];
    }
    #spawn() {
      const w = new Worker(this.url);
      w.onmessage = e => {
        w._cb?.(e);
        w._cb = null;
        this.free.push(w);
        this.#kick();
      };
      return w;
    }
    run(msg, cb) {
      this.queue.push({ msg, cb });
      this.#kick();
    }
    #kick() {
      if (!this.free.length || !this.queue.length) return;
      const { msg, cb } = this.queue.shift();
      const w = this.free.pop();
      w._cb = cb;
      w.postMessage(msg, [msg.pos.buffer, msg.scl.buffer, msg.rad.buffer]);
    }
  }
  const pool = new WorkerPool(workerURL, 8);
  const runWorker = (task, cb) => pool.run(task, cb);

  /* ---------- BVH/Octree data & leaf records --------------------------- */
  let nodeData = null;         // Float32Array: [cx, cy, cz, hx, hy, hz] × nodeCount
  let isLeafArr = null;        // Uint8Array: leaf=1 / internal=0
  let childLArr = null;        // Int32Array for BVH only
  let childRArr = null;        // Int32Array for BVH only
  let octChildrenIndices = null;// Array<Uint32Array> for octree only
  let leafContents = null;     // Array<Uint32Array>, indexed by nodeIndex if leaf
  let highlightedLeafIndex = null;   // currently highlighted node index
  let highlightBoxMesh = null;       // single highlight box
  let currentStructure = "bvh";

  // ** NEW: precomputed min/max arrays for each AABB **
  let nodeMinX = null, nodeMinY = null, nodeMinZ = null;
  let nodeMaxX = null, nodeMaxY = null, nodeMaxZ = null;

  /* ---------- collision info table container --------------------------- */
  const collisionDiv = document.getElementById("collisionTable");

  /* ---------- UI & rebuild ----------------------------------------------- */
  const sel = document.getElementById("structure");
  const minIn = document.getElementById("minLeaf");
  const numIn = document.getElementById("numPts");
  const stats = document.getElementById("stats");
  document.getElementById("rebuild").onclick = rebuild;
  document.getElementById("shoot").onclick = shootBall;

  let version = 0;
  rebuild();

  function rebuild() {
    const n = +numIn.value;
    currentPts = genPoints(n);
    version++;
    currentStructure = sel.value;

    const posCopy = new Float32Array(currentPts.pos);
    const sclCopy = new Float32Array(currentPts.scl);
    const radCopy = new Float32Array(currentPts.rad);

    runWorker({
      version,
      structure: sel.value,
      cubic: sel.value === "octCube",
      minLeaf: +minIn.value,
      pos: posCopy,
      scl: sclCopy,
      rad: radCopy
    }, onWorkerMessage);
  }

  function onWorkerMessage(e) {
    if (e.data.version !== version) return; // ignore stale

    const { data, leaf, buildTime, leafIdxs } = e.data;
    const nodeCount = leaf.length;
    const nPts = currentPts.pos.length / 3;

    // 1) store original [cx,cy,cz,hx,hy,hz]
    nodeData = data;        // Float32Array(6 * nodeCount)
    isLeafArr = leaf;       // Uint8Array(nodeCount)

    // 2) build min/max arrays once (minX,Y,Z and maxX,Y,Z for each node)
    nodeMinX = new Float32Array(nodeCount);
    nodeMinY = new Float32Array(nodeCount);
    nodeMinZ = new Float32Array(nodeCount);
    nodeMaxX = new Float32Array(nodeCount);
    nodeMaxY = new Float32Array(nodeCount);
    nodeMaxZ = new Float32Array(nodeCount);
    for (let i = 0; i < nodeCount; i++) {
      const base = i * 6;
      const cx = data[base];
      const cy = data[base + 1];
      const cz = data[base + 2];
      const hx = data[base + 3];
      const hy = data[base + 4];
      const hz = data[base + 5];
      nodeMinX[i] = cx - hx;
      nodeMaxX[i] = cx + hx;
      nodeMinY[i] = cy - hy;
      nodeMaxY[i] = cy + hy;
      nodeMinZ[i] = cz - hz;
      nodeMaxZ[i] = cz + hz;
    }

    // Dispose existing highlight box before rebuilding
    if (highlightBoxMesh) {
      highlightBoxMesh.dispose();
      highlightBoxMesh = null;
      highlightedLeafIndex = null;
    }

    // Build leafContents map (nodeIndex → its points)
    leafContents = new Array(nodeCount);
    for (let i = 0; i < nodeCount; i++) {
      leafContents[i] = undefined;
    }
    let leafCountSoFar = 0;
    for (let i = 0; i < nodeCount; i++) {
      if (isLeafArr[i] === 1) {
        leafContents[i] = leafIdxs[leafCountSoFar++];
      }
    }

    if (sel.value === "bvh") {
      childLArr = e.data.childL;   // Int32Array(nodeCount)
      childRArr = e.data.childR;   // Int32Array(nodeCount)
      octChildrenIndices = null;
    } else {
      childLArr = null;
      childRArr = null;
      octChildrenIndices = e.data.childrenIdxs; // Array<Uint32Array>
    }

    // Populate point cloud
    ensure(ptInst, ptT, nPts);
    for (let i = 0; i < nPts; i++) {
      const m = ptInst[i];
      const b = i * 3;
      m.position.set(
        currentPts.pos[b],
        currentPts.pos[b + 1],
        currentPts.pos[b + 2]
      );
      m.scaling.set(2, 2, 2);
    }

    // Populate BVH/Octree boxes (leaf and internal)
    let leafCnt = 0, intCnt = 0;
    for (const f of isLeafArr) {
      if (f) leafCnt++;
      else intCnt++;
    }
    ensure(leafInst, leafT, leafCnt);
    ensure(intInst, intT, intCnt);

    let li = 0, ii = 0;
    for (let i = 0; i < nodeCount; i++) {
      const d = i * 6;
      const cx = nodeData[d], cy = nodeData[d + 1], cz = nodeData[d + 2];
      const hx = nodeData[d + 3], hy = nodeData[d + 4], hz = nodeData[d + 5];
      const inst = isLeafArr[i] ? leafInst[li++] : intInst[ii++];
      inst.position.set(cx, cy, cz);
      inst.scaling.set(hx * 2, hy * 2, hz * 2);
    }

    stats.textContent =
      `Nodes: ${nodeCount.toLocaleString()}  |  Build ${buildTime.toFixed(2)} ms`;

    collisionDiv.innerHTML = "";
  }

  /* ---------- Ball & Collision Logic ------------------------------------ */
  let ballMesh = null;
  let ballVelocity = new BABYLON.Vector3();
  const ballSpeed = 200;       // units/sec
  const ballRadius = 2;        // sphere radius=2 (diameter=4)
  let isBallActive = false;
  let ballSpawnTime = 0;
  const ballMaxLifetime = 5000; // ms

  function shootBall() {
    if (!nodeData) {
      console.warn("BVH/Octree not built yet. Rebuild and try again.");
      return;
    }
    // Dispose old ball
    if (ballMesh) {
      ballMesh.dispose();
      isBallActive = false;
    }

    // Create new ball at camera
    const camPos = cam.position.clone();
    ballMesh = BABYLON.MeshBuilder.CreateSphere(
      "ball", { diameter: ballRadius * 2 }, scene
    );
    ballMesh.position.copyFrom(camPos);
    ballMesh.material = new BABYLON.StandardMaterial("ballMat", scene);
    ballMesh.material.diffuseColor.set(0.8, 0.2, 0.2);
    ballMesh.renderingGroupId = 0;

    // Direction from camera to target
    const dir = cam.target.clone().subtract(camPos).normalize();
    ballVelocity = dir.scale(ballSpeed);

    ballSpawnTime = performance.now();
    isBallActive = true;

    // Clear previous info/highlight
    collisionDiv.innerHTML = "";
    if (highlightBoxMesh) {
      highlightBoxMesh.dispose();
      highlightBoxMesh = null;
      highlightedLeafIndex = null;
    }
  }

  scene.registerBeforeRender(() => {
    if (!isBallActive || !ballMesh) return;

    const now = performance.now();
    if (now - ballSpawnTime >= ballMaxLifetime) {
      ballMesh.dispose();
      isBallActive = false;
      return;
    }

    const delta = engine.getDeltaTime() / 1000;
    ballMesh.position.addInPlace(ballVelocity.scale(delta));

    console.time("Tree Descent");
    // --- Find collided leaf via tree descent (O(depth)) ---
    let collidedLeafNodeIndex = -1;
    if (currentStructure === "bvh") {
      collidedLeafNodeIndex = findLeafBVH(ballMesh.position);
    } else {
      collidedLeafNodeIndex = findLeafOct(ballMesh.position);
    }
    console.timeEnd("Tree Descent");

    if (collidedLeafNodeIndex < 0) {
      // Not inside any leaf (shouldn't happen if scene large enough)
      return;
    }

    // --- Check particles in that leaf for actual collision ---
    const indices = leafContents[collidedLeafNodeIndex];
    if (!indices || indices.length === 0) {
      // no points in this leaf
    } else {
      let particleHit = -1;
      const pxArr = currentPts.pos;
      const prArr = currentPts.rad;
      const pos = ballMesh.position;
      for (let i = 0; i < indices.length; i++) {
        const idx = indices[i];
        const px = pxArr[3 * idx];
        const py = pxArr[3 * idx + 1];
        const pz = pxArr[3 * idx + 2];
        const dx = pos.x - px;
        const dy = pos.y - py;
        const dz = pos.z - pz;
        const distSq = dx * dx + dy * dy + dz * dz;
        const radiusSum = ballRadius + prArr[idx];
        if (distSq <= radiusSum * radiusSum) {
          particleHit = idx;
          console.log("Leaf particles: ", indices)
          break;
        }
      }
      if (particleHit < 0) {
        // No orb‐collision yet; highlight current leaf
        if (highlightBoxMesh && highlightedLeafIndex !== collidedLeafNodeIndex) {
          highlightBoxMesh.dispose();
          highlightBoxMesh = null;
        }
        if (!highlightBoxMesh || highlightedLeafIndex !== collidedLeafNodeIndex) {
          const d = collidedLeafNodeIndex * 6;
          const cx = nodeData[d], cy = nodeData[d + 1], cz = nodeData[d + 2];
          const hx = nodeData[d + 3], hy = nodeData[d + 4], hz = nodeData[d + 5];
          highlightBoxMesh = BABYLON.MeshBuilder.CreateBox(
            "highlightBox",
            { width: hx * 2, height: hy * 2, depth: hz * 2 },
            scene
          );
          highlightBoxMesh.position.set(cx, cy, cz);
          highlightBoxMesh.material = matHighlight;
          highlightBoxMesh.renderingGroupId = 1;
          highlightedLeafIndex = collidedLeafNodeIndex;
        }
        return;
      }
    }

    // --- Actual orb collision occurred! Build hierarchy path -----------
    let hierarchyPath;
    if (currentStructure === "bvh") {
      hierarchyPath = collectHierarchyBVH(ballMesh.position);
    } else {
      hierarchyPath = collectHierarchyOct(ballMesh.position);
    }

    // --- Build HTML table from hierarchyPath ---
    let html = `
      <table border="1" cellpadding="4" style="width:100%; text-align:center;">
        <tr><th>Node Index</th></tr>
    `;
    hierarchyPath.forEach(idx => {
      html += `<tr data-node="${idx}"><td>${idx}</td></tr>`;
    });
    html += `</table>`;
    collisionDiv.innerHTML = html;

    // --- Attach hover listeners to rows ---
    const rows = collisionDiv.querySelectorAll("tr[data-node]");
    rows.forEach(row => {
      const nodeIdx = parseInt(row.getAttribute("data-node"));
      row.addEventListener("mouseenter", () => {
        if (highlightBoxMesh && highlightedLeafIndex !== nodeIdx) {
          highlightBoxMesh.dispose();
          highlightBoxMesh = null;
        }
        if (!highlightBoxMesh || highlightedLeafIndex !== nodeIdx) {
          const d = nodeIdx * 6;
          const cx = nodeData[d], cy = nodeData[d + 1], cz = nodeData[d + 2];
          const hx = nodeData[d + 3], hy = nodeData[d + 4], hz = nodeData[d + 5];
          highlightBoxMesh = BABYLON.MeshBuilder.CreateBox(
            "highlightBox",
            { width: hx * 2, height: hy * 2, depth: hz * 2 },
            scene
          );
          highlightBoxMesh.position.set(cx, cy, cz);
          highlightBoxMesh.material = matHighlight;
          highlightBoxMesh.renderingGroupId = 1;
          highlightedLeafIndex = nodeIdx;
        }
        row.classList.add("highlighted");
      });
      row.addEventListener("mouseleave", () => {
        // Revert to collided leaf highlight
        if (highlightBoxMesh && highlightedLeafIndex !== collidedLeafNodeIndex) {
          highlightBoxMesh.dispose();
          highlightBoxMesh = null;
        }
        if (!highlightBoxMesh || highlightedLeafIndex !== collidedLeafNodeIndex) {
          const d = collidedLeafNodeIndex * 6;
          const cx = nodeData[d], cy = nodeData[d + 1], cz = nodeData[d + 2];
          const hx = nodeData[d + 3], hy = nodeData[d + 4], hz = nodeData[d + 5];
          highlightBoxMesh = BABYLON.MeshBuilder.CreateBox(
            "highlightBox",
            { width: hx * 2, height: hy * 2, depth: hz * 2 },
            scene
          );
          highlightBoxMesh.position.set(cx, cy, cz);
          highlightBoxMesh.material = matHighlight;
          highlightBoxMesh.renderingGroupId = 1;
          highlightedLeafIndex = collidedLeafNodeIndex;
        }
        row.classList.remove("highlighted");
      });
    });

    // Destroy the ball
    ballMesh.dispose();
    isBallActive = false;
  });

  /* ---------- BVH path collector (using precomputed min/max) ------------ */
  /**
   * Descend the BVH from the root (node 0) and return the index of the leaf
   * that genuinely contains (point.x, point.y, point.z). If the point lies
   * outside the root’s AABB, return -1.
   *
   * Uses precomputed nodeMinX/Y/Z and nodeMaxX/Y/Z arrays so there are no
   * subtractions inside the hot loop—only raw comparisons.
   */
  function findLeafBVH(point) {
    const minXarr = nodeMinX,
          minYarr = nodeMinY,
          minZarr = nodeMinZ,
          maxXarr = nodeMaxX,
          maxYarr = nodeMaxY,
          maxZarr = nodeMaxZ;
    const leafF = isLeafArr;
    const cL    = childLArr;
    const cR    = childRArr;

    const px = point.x, py = point.y, pz = point.z;
    // Root‐AABB test:
    if (
      px < minXarr[0] || px > maxXarr[0] ||
      py < minYarr[0] || py > maxYarr[0] ||
      pz < minZarr[0] || pz > maxZarr[0]
    ) {
      return -1;
    }

    let nodeIdx = 0;
    while (true) {
      if (leafF[nodeIdx] === 1) {
        return nodeIdx;
      }

      // Try left child
      const L = cL[nodeIdx];
      if (L >= 0) {
        const lx0 = minXarr[L], ly0 = minYarr[L], lz0 = minZarr[L];
        const lx1 = maxXarr[L], ly1 = maxYarr[L], lz1 = maxZarr[L];
        if (
          px >= lx0 && px <= lx1 &&
          py >= ly0 && py <= ly1 &&
          pz >= lz0 && pz <= lz1
        ) {
          nodeIdx = L;
          continue;
        }
      }

      // Try right child
      const R = cR[nodeIdx];
      if (R >= 0) {
        const rx0 = minXarr[R], ry0 = minYarr[R], rz0 = minZarr[R];
        const rx1 = maxXarr[R], ry1 = maxYarr[R], rz1 = maxZarr[R];
        if (
          px >= rx0 && px <= rx1 &&
          py >= ry0 && py <= ry1 &&
          pz >= rz0 && pz <= rz1
        ) {
          nodeIdx = R;
          continue;
        }
      }

      // Forced descent if one child is a leaf
      if (L >= 0 && leafF[L] === 1) {
        nodeIdx = L;
        continue;
      }
      if (R >= 0 && leafF[R] === 1) {
        nodeIdx = R;
        continue;
      }

      return -1;
    }
  }

  /**
   * Return the full root→…→leaf path (array of node‐indices) for (x,y,z).
   * If (x,y,z) lies outside the root’s AABB, return [].
   *
   * Uses the same precomputed min/max tables for zero‐subtraction checks.
   */
  function collectHierarchyBVH(point) {
    const minXarr = nodeMinX,
          minYarr = nodeMinY,
          minZarr = nodeMinZ,
          maxXarr = nodeMaxX,
          maxYarr = nodeMaxY,
          maxZarr = nodeMaxZ;
    const leafF = isLeafArr;
    const cL    = childLArr;
    const cR    = childRArr;

    const px = point.x, py = point.y, pz = point.z;
    // Root‐AABB test:
    if (
      px < minXarr[0] || px > maxXarr[0] ||
      py < minYarr[0] || py > maxYarr[0] ||
      pz < minZarr[0] || pz > maxZarr[0]
    ) {
      return [];
    }

    const path = [];
    let nodeIdx = 0;
    while (true) {
      path.push(nodeIdx);
      if (leafF[nodeIdx] === 1) {
        break;
      }

      // Try left child
      const L = cL[nodeIdx];
      if (L >= 0) {
        const lx0 = minXarr[L], ly0 = minYarr[L], lz0 = minZarr[L];
        const lx1 = maxXarr[L], ly1 = maxYarr[L], lz1 = maxZarr[L];
        if (
          px >= lx0 && px <= lx1 &&
          py >= ly0 && py <= ly1 &&
          pz >= lz0 && pz <= lz1
        ) {
          nodeIdx = L;
          continue;
        }
      }

      // Try right child
      const R = cR[nodeIdx];
      if (R >= 0) {
        const rx0 = minXarr[R], ry0 = minYarr[R], rz0 = minZarr[R];
        const rx1 = maxXarr[R], ry1 = maxYarr[R], rz1 = maxZarr[R];
        if (
          px >= rx0 && px <= rx1 &&
          py >= ry0 && py <= ry1 &&
          pz >= rz0 && pz <= rz1
        ) {
          nodeIdx = R;
          continue;
        }
      }

      // Forced descent if one child is a leaf
      if (L >= 0 && leafF[L] === 1) {
        nodeIdx = L;
        continue;
      }
      if (R >= 0 && leafF[R] === 1) {
        nodeIdx = R;
        continue;
      }

      break;
    }

    return path;
  }

  /* ---------- Octree path collector (unchanged) -------------------------- */
  function findLeafOct(point) {
    let nodeIdx = 0;
    while (true) {
      if (isLeafArr[nodeIdx] === 1) {
        return nodeIdx;
      }
      const children = octChildrenIndices[nodeIdx];
      let moved = false;
      for (let i = 0, len = children.length; i < len; i++) {
        const c = children[i];
        const cd = c * 6;
        const cx = nodeData[cd], cy = nodeData[cd + 1], cz = nodeData[cd + 2];
        const hx = nodeData[cd + 3], hy = nodeData[cd + 4], hz = nodeData[cd + 5];
        if (
          point.x >= cx - hx && point.x <= cx + hx &&
          point.y >= cy - hy && point.y <= cy + hy &&
          point.z >= cz - hz && point.z <= cz + hz
        ) {
          nodeIdx = c;
          moved = true;
          break;
        }
      }
      if (!moved) {
        return -1;
      }
    }
  }

  function collectHierarchyOct(point) {
    const path = [];
    let nodeIdx = 0;
    while (true) {
      path.push(nodeIdx);
      if (isLeafArr[nodeIdx] === 1) {
        break;
      }
      const children = octChildrenIndices[nodeIdx];
      let moved = false;
      for (let i = 0, len = children.length; i < len; i++) {
        const c = children[i];
        const cd = c * 6;
        const cx = nodeData[cd], cy = nodeData[cd + 1], cz = nodeData[cd + 2];
        const hx = nodeData[cd + 3], hy = nodeData[cd + 4], hz = nodeData[cd + 5];
        if (
          point.x >= cx - hx && point.x <= cx + hx &&
          point.y >= cy - hy && point.y <= cy + hy &&
          point.z >= cz - hz && point.z <= cz + hz
        ) {
          nodeIdx = c;
          moved = true;
          break;
        }
      }
      if (!moved) {
        break;
      }
    }
    return path;
  }

  /* ---------- render loop ----------------------------------------------- */
  engine.runRenderLoop(() => scene.render());
  window.addEventListener("resize", () => engine.resize());
</script>

</body>

</html>